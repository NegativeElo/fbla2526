<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Computer Scientist</title>
  <script src="https://unpkg.com/blockly@9.3.3/blockly.min.js"></script>
  <style>
    body { background: linear-gradient(120deg,#f0f3f8,#e3e8f6 80%); font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif; color:#222; margin:0;padding:20px;text-align:center;}
    h2{color:#1976d2;}
    h3{color:#1976d2;}
    #container{display:flex;gap:18px;justify-content:center;align-items:flex-start;flex-wrap:wrap;}
    #blocklyDiv{width:560px;height:520px;border:3px solid #1976d2;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.07);background:white;}
    #rightCol{width:420px;text-align:center;}
    canvas{border:3px solid #1976d2;background-color:#fff;display:block;margin:12px auto;border-radius:14px;box-shadow:0 2px 10px #1976d21c;}
    button{background:#1976d2;color:white;border:none;border-radius:7px;padding:12px 18px;font-size:1rem;cursor:pointer;transition:background 0.16s;}
    button:disabled, button.disabled-button {
      opacity: 0.5;
      cursor: default;
    }
    #return {
      position: absolute;
      top: 20px;
      right: 32px;
      z-index: 100;
    }
    #hint{font-size:0.9rem;color:#444;margin-top:6px;}
    .scoreboard{display:flex;justify-content:center;align-items:center;gap:32px;margin-bottom:8px;font-size:1.1rem;font-weight:bold;letter-spacing:0.02em;}
    .timer{background:#ffe082;color:#333;padding:6px 16px;border-radius:18px;border:1px solid #ffd54f;}
    .score{background:#c8e6c9;color:#1b5e20;padding:6px 18px;border-radius:18px;border:1px solid #a5d6a7;}
    #notify { color: #2c7a17; font-size: 1.04rem; min-height: 24px; margin-bottom: 9px; transition: opacity 0.3s;}
  </style>
</head>
<body>
  <button id="return">Return to main page</button>
  <h2>Welcome to the career world of a computer scientist!</h2>
  <h3>You must use the blocks provided to move the red circle to the green circle! You will have 120 seconds to complete as many challenges as possible! Have fun!</h3>
  <div id="container">
    <div id="blocklyDiv"></div>
    <div id="rightCol">
      <div class="scoreboard">
        <span class="timer" id="timer">‚è≥ Time: 120</span>
        <span class="score" id="score">Score: 0</span>
      </div>
      <p id="notify"></p>
      <canvas id="gameCanvas" width="400" height="400"></canvas>
      <div>
        <button id="runBtn">Run</button>
        <button id="stopBtn" disabled>Reset</button>
        <button id="playAgainBtn" style="display:none;">Play Again</button>
      </div>
      <div id="hint">Tip: Use <strong>Reset</strong> to try again if stuck. Drag movement blocks and use loops to solve challenges!</div>
    </div>
  </div>
  <xml id="toolbox" style="display:none">
    <category name="Movement" colour="#2E7D32">
      <block type="move_north"></block>
      <block type="move_south"></block>
      <block type="move_east"></block>
      <block type="move_west"></block>
    </category>
    <category name="Loops" colour="#1565C0">
      <block type="controls_repeat_ext">
        <value name="TIMES">
          <shadow type="math_number"><field name="NUM">4</field></shadow>
        </value>
      </block>
    </category>
  </xml>
  <script>
    const returnButton = document.getElementById("return");
    returnButton.addEventListener("click", function () {
        if(confirm("Are you sure you would like to leave this page? Your progress will not be saved.")) {
            window.location.href = "/../index.html"
        }
    });
    window.onload = function() {
      const workspace = Blockly.inject('blocklyDiv', { toolbox: document.getElementById('toolbox'), scrollbars:true, trashcan:true });
      Blockly.defineBlocksWithJsonArray([
        { "type": "move_north", "message0": "moveNorth()", "previousStatement": null, "nextStatement": null, "colour": 120 },
        { "type": "move_south", "message0": "moveSouth()", "previousStatement": null, "nextStatement": null, "colour": 120 },
        { "type": "move_east",  "message0": "moveEast()",  "previousStatement": null, "nextStatement": null, "colour": 120 },
        { "type": "move_west",  "message0": "moveWest()",  "previousStatement": null, "nextStatement": null, "colour": 120 }
      ]);
      Blockly.JavaScript['move_north'] = () => 'moveNorth();\n';
      Blockly.JavaScript['move_south'] = () => 'moveSouth();\n';
      Blockly.JavaScript['move_east'] = () => 'moveEast();\n';
      Blockly.JavaScript['move_west'] = () => 'moveWest();\n';

      const cols = 10, rows = 10, gridSize = 40, canvasSize = 400;
      const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
      const notify = document.getElementById('notify');

      let startPlayer = {}, startIngredient = {}, startObstacles = [];
      let player = {}, ingredient = {}, obstacleCoords = [];
      let playerActive = true, ingredientActive = true, timer = 120, score = 0, gameActive = false, timerInterval = null, isRunning = false, timerStarted = false;
      let justCollected = false;

      function getRandomSetup() {
        let available = [];
        for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) available.push({ x, y });
        for (let i = available.length - 1; i > 0; i--) {
          let j = Math.floor(Math.random() * (i + 1));
          [available[i], available[j]] = [available[j], available[i]];
        }
        let player = available.pop();
        let ingredient = available.pop();
        const blockCount = 12 + Math.floor(Math.random() * 5);
        let obstacles = [];
        while (obstacles.length < blockCount && available.length > 0) {
          obstacles.push(available.pop());
        }
        return { player, ingredient, obstacles };
      }

      function setChallengePositions(newSetup) {
        startPlayer = { ...newSetup.player };
        startIngredient = { ...newSetup.ingredient };
        startObstacles = newSetup.obstacles.map(o => ({ ...o }));
        resetToChallengePositions();
      }
      function resetToChallengePositions() {
        player = { ...startPlayer };
        ingredient = { ...startIngredient };
        obstacleCoords = startObstacles.map(o => ({ ...o }));
        playerActive = true;
        ingredientActive = true;
        justCollected = false;
        draw();

        // Reset Run button style and disabled state properly
        runBtn.disabled = false;
        runBtn.classList.remove('disabled-button');

        stopBtn.disabled = true;
      }
      function draw() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1;
        for (let i = 0; i <= cols; i++) { ctx.beginPath(); ctx.moveTo(i * gridSize, 0); ctx.lineTo(i * gridSize, canvasSize); ctx.stroke(); }
        for (let j = 0; j <= rows; j++) { ctx.beginPath(); ctx.moveTo(0, j * gridSize); ctx.lineTo(canvasSize, j * gridSize); ctx.stroke(); }
        for (let o of obstacleCoords) {
          ctx.fillStyle = '#121213';
          ctx.beginPath(); ctx.arc(o.x * gridSize + gridSize / 2, o.y * gridSize + gridSize / 2, gridSize / 2.2, 0, 2 * Math.PI); ctx.fill();
        }
        if (ingredientActive || justCollected) {
          ctx.beginPath();
          ctx.arc(ingredient.x * gridSize + gridSize / 2, ingredient.y * gridSize + gridSize / 2, gridSize / 2.5, 0, 2 * Math.PI);
          ctx.closePath(); ctx.fillStyle = '#38b000'; ctx.fill(); ctx.strokeStyle = '#225e19'; ctx.lineWidth = 2; ctx.stroke();
        }
        // Player always drawn, regardless of isRunning or crash
        ctx.beginPath();
        ctx.arc(player.x * gridSize + gridSize / 2, player.y * gridSize + gridSize / 2, gridSize / 2.5, 0, 2 * Math.PI);
        ctx.closePath(); ctx.fillStyle = '#e53935'; ctx.fill(); ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 2; ctx.stroke();
      }

      function checkBlocked(x, y) { return obstacleCoords.some(ob => ob.x === x && ob.y === y); }
      function showNotify(msg) {
        notify.textContent = msg;
        notify.style.opacity = '1';
        setTimeout(() => { notify.style.opacity = '0.64'; }, 1200);
      }
      function startTimerIfNeeded() {
        if (!timerStarted) {
          timerStarted = true;
          timer = 120;
          document.getElementById('timer').textContent = "‚è≥ Time: " + timer;
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = setInterval(() => {
            timer--;
            document.getElementById('timer').textContent = "‚è≥ Time: " + timer;
            if (timer <= 0) {
              clearInterval(timerInterval); gameActive = false;
              showNotify(`Time's up! Collected: ${score}`);

              // Disable and visually dull Run button
              runBtn.disabled = true;
              runBtn.classList.add('disabled-button');

              document.getElementById('playAgainBtn').style.display = "inline-block";
              isRunning = false;
              timerStarted = false;

              stopBtn.disabled = false;
            }
          }, 1000);
        }
      }

      function checkCollision() {
        if (player.x < 0 || player.x >= cols || player.y < 0 || player.y >= rows) {
          showNotify("Error: Out of bounds!");
          isRunning = false;

          // Disable and dull run button
          runBtn.disabled = true;
          runBtn.classList.add('disabled-button');

          stopBtn.disabled = false;
          return false;
        }
        if (checkBlocked(player.x, player.y)) {
          showNotify("Crashed into a blocked tile! Please reset.");
          isRunning = false;

          // Disable and dull run button
          runBtn.disabled = true;
          runBtn.classList.add('disabled-button');

          stopBtn.disabled = false;
          return false;
        }
        if (ingredientActive && player.x === ingredient.x && player.y === ingredient.y) {
          justCollected = true;
          draw();
          setTimeout(() => {
            justCollected = false;
            ingredientActive = false;
            score++;
            document.getElementById('score').textContent = "Score: " + score;
            showNotify(`üéâ You collected an ingredient!`);
            setTimeout(() => {
              if (gameActive && timer > 0) {
                setChallengePositions(getRandomSetup());
                isRunning = false;

                runBtn.disabled = false;
                runBtn.classList.remove('disabled-button');

                stopBtn.disabled = false;
              }
            }, 340);
          }, 180);
          return false;
        }
        return true;
      }

      const moveQueue = [];
      let processing = false;
      function enqueueMove(fn) { moveQueue.push(fn); processQueue(); }
      async function processQueue() {
        if (processing) return;
        processing = true;
        while (moveQueue.length > 0 && isRunning && gameActive) {
          const fn = moveQueue.shift();
          fn();
          if (!checkCollision()) {
            break;
          }
          draw();
          await delay(300);
        }
        processing = false;
        if (!isRunning || !gameActive) {
          runBtn.disabled = true;
          runBtn.classList.add('disabled-button');

          stopBtn.disabled = false;
        }
      }
      function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

      function attemptMove(dx, dy) {
        const nx = player.x + dx, ny = player.y + dy;
        if (checkBlocked(nx, ny)) {
          showNotify("Blocked! Take a detour.");
          isRunning = false;
          moveQueue.length = 0;

          runBtn.disabled = true;
          runBtn.classList.add('disabled-button');

          return false;
        }
        player.x = nx; player.y = ny;
        return true;
      }
      function moveEast()  { enqueueMove(() => { if (!attemptMove(1, 0)) moveQueue.length = 0; }); }
      function moveWest()  { enqueueMove(() => { if (!attemptMove(-1, 0)) moveQueue.length = 0; }); }
      function moveNorth() { enqueueMove(() => { if (!attemptMove(0, -1)) moveQueue.length = 0; }); }
      function moveSouth() { enqueueMove(() => { if (!attemptMove(0, 1)) moveQueue.length = 0; }); }

      const runBtn = document.getElementById('runBtn'),
            stopBtn = document.getElementById('stopBtn'),
            playAgainBtn = document.getElementById('playAgainBtn');

      runBtn.addEventListener('click', () => {
        if (isRunning || timer <= 0) return;
        isRunning = true; gameActive = true;
        runBtn.disabled = true;
        runBtn.classList.add('disabled-button');
        stopBtn.disabled = false; playAgainBtn.style.display = "none";
        notify.textContent = "";
        startTimerIfNeeded();
        const code = Blockly.JavaScript.workspaceToCode(workspace);
        try { eval(`(async()=>{${code}})();`); } catch (e) { showNotify("Code error! " + e); }
      });

      stopBtn.addEventListener('click', () => {
        moveQueue.length = 0; processing = false;
        isRunning = false;
        resetToChallengePositions();
        draw();
        runBtn.disabled = false;
        runBtn.classList.remove('disabled-button');
        stopBtn.disabled = true;
      });

      playAgainBtn.addEventListener('click', () => {
        moveQueue.length = 0; processing = false; isRunning = false; gameActive = false;
        setChallengePositions(getRandomSetup());
        workspace.clear(); notify.textContent = "";
        document.getElementById('score').textContent = "Score: 0";
        document.getElementById('playAgainBtn').style.display = "none";
        runBtn.disabled = false;
        runBtn.classList.remove('disabled-button');
        stopBtn.disabled = true;
        timerStarted = false;
        timer = 120; document.getElementById('timer').textContent = "‚è≥ Time: 120";
        if (timerInterval) clearInterval(timerInterval);
      });

      window.addEventListener('keydown', e => { if (e.ctrlKey && e.key === 'Enter') { runBtn.click(); } });

      Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(`
        <xml xmlns="http://www.w3.org/1999/xhtml">
          <block type="controls_repeat_ext" x="20" y="20">
            <value name="TIMES"><shadow type="math_number"><field name="NUM">3</field></shadow></value>
            <statement name="DO"><block type="move_east"></block></statement>
          </block>
        </xml>`), workspace);

      setChallengePositions(getRandomSetup());
    };
  </script>
</body>
</html>
